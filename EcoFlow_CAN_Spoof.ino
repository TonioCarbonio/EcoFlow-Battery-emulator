#include <mcp_can.h>
#include <SPI.h>

#define CAN_CS_PIN 10
MCP_CAN CAN(CAN_CS_PIN);

#define SEND_INTERVAL 0.5

// Header
unsigned char header[] = {
    0xaa, 0x03, 0x84, 0x00, 0x3c, 0x2e, 0xac, 0x04,
    0x00, 0x00, 0x0b, 0x3c, 0x03, 0x14, 0x01, 0x01,
    0x03, 0x2f
};

// Message
unsigned char message[] = {
    0x01, 0x84, 0x00, 0x4d, 0x31, 0x30, 0x32, 0x5a, 0x33, 0x42, 0x34, 0x5a, 0x45, 0x35,
    0x48, 0x30, 0x36, 0x30, 0x31, 0x3c, 0x00, 0x0b,
    0x00, 0x01, 0x4d, 0x03, 0x01, 0x01, 0x11, 0x01,
    0x00, 0x01, 0x02, 0x01, 0x02, 0x00, 0xc8, 0x00,
    0x00, 0x01, 0x00, 0x6e, 0xd2, 0x00, 0x00, 0x51,
    0x56, 0x00, 0x00, 0x01, 0x00, 0x02, 0x8e, 0x88,
    0x05, 0x41, 0x0f, 0x9a, 0xca, 0x00, 0x00, 0x49,
    0xff, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x40, 0x9c,
    0x00, 0x00, 0x7f, 0x32, 0x02, 0x00, 0x7a, 0x02,
    0x00, 0x00, 0x64, 0x05, 0x00, 0x64
};

// CRC16 function to calculate the checksum
unsigned int crc16(const unsigned char *data, unsigned int length) {
    unsigned int crc = 0xFFFF;
    for (unsigned int i = 0; i < length; i++) {
        crc ^= data[i];
        for (unsigned int j = 8; j; j--) {
            if (crc & 0x01) crc = (crc >> 1) ^ 0xA001;
            else crc >>= 1;
        }
    }
    return crc;
}

// Function to send the data over CAN bus
void send_data() {
    unsigned char msg[sizeof(header) + sizeof(message)];
    
    // Copy header and message into the msg array
    memcpy(msg, header, sizeof(header));
    memcpy(msg + sizeof(header), message, sizeof(message));
    
    // Calculate CRC16 and append it to the message
    unsigned int crc = crc16(msg, sizeof(msg));
    msg[sizeof(msg) - 2] = crc & 0xFF;
    msg[sizeof(msg) - 1] = (crc >> 8) & 0xFF;

    int msg_len = sizeof(msg);
    // Send message in chunks of 8 bytes
    for (int i = 0; i < msg_len / 8; i++) {
        unsigned char data_chunk[8];
        memcpy(data_chunk, msg + i * 8, 8);
        CAN.sendMsgBuf(0x10003001 + i, 0, 8, data_chunk);
    }
    Serial.println("Messaggio inviato!");
}

void setup() {
    Serial.begin(115200);

    // Inizializza CAN a 1 Mbps con quarzo da 8 MHz
    if (CAN.begin(MCP_ANY, CAN_1000KBPS, MCP_8MHZ) == CAN_OK) {
        Serial.println("CAN bus inizializzato correttamente a 1 Mbps su 8 MHz!");
    } else {
        Serial.println("Errore nell'inizializzazione del CAN bus.");
        while (1);
    }

    CAN.setMode(MCP_NORMAL); // modalitÃ  normale (no loopback o sleep)
}
void loop() {
    send_data();
    delay(SEND_INTERVAL * 1000); // Delay between sending messages
}
